{
  "questions": [
    {
      "id": 1,
      "question": "Given two tables, Employee(EmpID, Name, DeptID) and Department(DeptID, DeptName), which SQL query correctly retrieves a list of employees along with their department names?",
      "options": [
        "SELECT EmpID, Name, DeptName FROM Employee INNER JOIN Department ON Employee.DeptID = Department.DeptID;",
        "SELECT EmpID, Name, DeptName FROM Employee CROSS JOIN Department;",
        "SELECT EmpID, Name, DeptName FROM Employee FULL OUTER JOIN Department ON Employee.DeptID = Department.DeptID;",
        "SELECT EmpID, Name FROM Employee LEFT JOIN Department ON Employee.DeptID = Department.DeptID;"
      ],
      "correctAnswer": 0,
      "explanation": "An INNER JOIN retrieves matching records from both tables based on the condition specified (Employee.DeptID = Department.DeptID)."
    },
    {
      "id": 2,
      "question": "Which of the following data structures is best suited to implement a database index?",
      "options": [
        "Hash Table",
        "Binary Search Tree",
        "B+ Tree",
        "Linked List"
      ],
      "correctAnswer": 2,
      "explanation": "B+ Trees are widely used for database indexing because they provide balanced tree properties and allow range queries efficiently."
    },
    {
      "id": 3,
      "question": "If a table contains 10,000 rows and a query performs a linear search, what is the worst-case time complexity?",
      "options": [
        "O(1)",
        "O(log n)",
        "O(n)",
        "O(n log n)"
      ],
      "correctAnswer": 2,
      "explanation": "In a linear search, the worst-case scenario requires traversing all n rows, resulting in O(n) complexity."
    },
    {
      "id": 4,
      "question": "Which of the following operations results in a higher cost in terms of time complexity in a relational database?",
      "options": [
        "Selection",
        "Insertion",
        "Natural Join",
        "Projection"
      ],
      "correctAnswer": 2,
      "explanation": "A natural join compares all common attributes of the tables, which can result in a Cartesian product followed by filtering, making it computationally expensive."
    },
    {
      "id": 5,
      "question": "What is the primary difference between B-Tree and B+ Tree in database indexing?",
      "options": [
        "B-Trees store all data in leaf and internal nodes, whereas B+ Trees store data only in leaf nodes.",
        "B+ Trees are unbalanced, whereas B-Trees are balanced.",
        "B+ Trees do not allow sequential access, while B-Trees do.",
        "B-Trees are faster than B+ Trees for range queries."
      ],
      "correctAnswer": 0,
      "explanation": "B+ Trees allow efficient sequential access as all data entries are stored in leaf nodes, unlike B-Trees."
    },
    {
      "id": 6,
      "question": "Which of the following ensures concurrency control in a DBMS?",
      "options": [
        "Two-phase locking protocol",
        "Hashing technique",
        "B+ Tree indexing",
        "Foreign key constraints"
      ],
      "correctAnswer": 0,
      "explanation": "The two-phase locking (2PL) protocol ensures serializability by dividing the transaction execution into two phases: the growing phase (acquiring locks) and the shrinking phase (releasing locks), preventing conflicts."
    },
    {
      "id": 7,
      "question": "What is the advantage of using views in SQL?",
      "options": [
        "They improve query performance.",
        "They enhance security by restricting access to specific data.",
        "They reduce storage space.",
        "They allow for faster data insertion."
      ],
      "correctAnswer": 1,
      "explanation": "Views allow users to see only specific columns or rows of a table without direct access to the base table, enhancing security and abstraction."
    },
    {
      "id": 8,
      "question": "In a transaction, which property ensures that all operations are completed successfully before committing?",
      "options": [
        "Consistency",
        "Atomicity",
        "Isolation",
        "Durability"
      ],
      "correctAnswer": 1,
      "explanation": "Atomicity ensures that a transaction is treated as a single, indivisible unit, meaning either all operations succeed, or none take effect, preventing partial updates."
    },
    {
      "id": 9,
      "question": "Which normal form eliminates partial dependency in a relational database?",
      "options": [
        "1NF",
        "2NF",
        "3NF",
        "BCNF"
      ],
      "correctAnswer": 1,
      "explanation": "Second Normal Form (2NF) removes partial dependency by ensuring that non-key attributes are fully functionally dependent on the primary key, avoiding redundancy."
    },
    {
      "id": 10,
      "question": "If a query with a GROUP BY clause is executed without an aggregate function, what will happen?",
      "options": [
        "It will return an error.",
        "It will return duplicate rows.",
        "It will group rows but not apply any calculations.",
        "It will return all rows without grouping."
      ],
      "correctAnswer": 0,
      "explanation": "The GROUP BY clause requires at least one aggregate function (such as COUNT, SUM, AVG) to produce meaningful results; otherwise, the SQL engine throws an error."
    }
  ]
}
